# 1. Jména, vazba, rozsahy platnosti

**jméno** = řetězec znaků, které mají zastupvat jiný objekt

**klíčové slova**
**rezervované slovo** 
     - v Jave `const` a `goto`

## Proměnné a vazby
### Proměnná
- typ
- doba života (lifetime)
- rozsah platnosti (scope)

V Pythonu se při přiřazení přesměruje odkaz. V C přiřazení mění hodnotu.

### Vazba
- **statická vazba** -- např. v C
- **dynamická vazba** 

_(Výčet "Okamžik vzniku vazby" nezkouší.)_

### Aliasing

V Pythonu `[Node()] * 3` vytvoří tři uzly ukazující na stejné místo v paměti (tz. když změním jeden, změní se i ostatní) - jsou to aliasy.

## Paměťová reprezentace objektů
**doba života**
- statické objekty = objekty s pevnou adresou
- objekty na zásobníku = 
- objekty na haldě = mohu (de)alkokovat kdykoli

C (de)alokace `malloc` a `free`.
Python vše na haldě.
C# referenced se alokují na hadě, value types na zásobníku.

### (Im)mutable objekty
V Haskellu je immutable všechno.

## Rozsahy platnosti (scope)
**statický rozsah** = hodnoty proměnných záleží na struktuře programu - hledám v úrovni syntakticky výš (Python, C, Java)

**dynamický rozsah** = hodnoty proměnných záleží na pořadí volání - používám zásovník volání (Lisp, TeX, Bash, PowerShell)

### Statický rozsah (static scope, lexical scope)
- běžně používané v programovacích jazycích

Rozsahy mají proměnné, ale i názvy funkcí.

Bloky (odsazení) v Pythonu nezavádí rozsah.
Python: `global`, `nonlocal`.

V C co je v `{}` je rozsah (takže i `if then` větve) - v Pythonu `if else` není nový rozsah.

Následující kód spadne. Proměnná je deklarovaná, protože je v rozsahu funkce (kdekoli), ale ještě nemá přiřazenou hodnotu, která je až na následujícím řádku. (To stejné nastává v C#)

```Python
c = 42
def foo():
    print(c)
    c = 121 # works if removed
foo()
```
V C je rozsah až do definice dál. V C by nastal problém s dvěmi navzájem volajícími se funkcemi, proto ale vzniklo oddělení definice a deklarace.

JavaScript = zlo; překlep v proměnné - nový název bez `var` mi může vytvořit novou proměnněnnou, bez vyhození chyby
V JS je možné použít `use strict`, které zakáže vytváření nových proměnných bez `let`.

_"Přepiš všechny `var` na `let` a uvidíš"_ - může pomoct

Poznámka k poslednímu slajdu: `scaled_score` bude počítat s `max_score` z procedury `foo`.